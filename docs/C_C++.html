<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <mate name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atom </title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
     <!-- Yandex.Metrika counter -->
     <script type="text/javascript" >
      (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
      m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
      (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

      ym(68914117, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
      });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/68914117" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->       
    

    <header>
      <div id="header">шапка сайта</div>
    </header>
    <main>
      <div id="menu">
        <br>  <a href="#p1">Файлы</a>     
        <br>  <a href="#p2">типы данных</a>      
        <br>  <a href="#p3">Set и Get</a>     
        <br>  <a href="#p4">Конструктор и деструктор</a>     
        <br>  <a href="#p5">Ссылки и указатели</a>     
        <br>  <a href="#p6">this</a>     
        <br>  <a href="#p7">Динамическая память</a>     
        <br>  <a href="#p8">Русские буквы в консоли</a>     
        <br>  <a href="#p9">Виртуальные функции</a>     
        <br>  <a href="#p10">Несколько файлов</a>     
        <br>  <a href="#p11">Компиляция линукс</a>     
        <br>  <a href="#p12">Системная пауза</a>     
        <br>  <a href="#p13">перегрузка в классе</a>     
        <br>  <a href="#p14">Конструктор</a>     
        <br>  <a href="#p15">Важные ссылки</a>     
        <br>  <a href="#p16">Vector</a>     
        <br>  <a href="#p17">Указатель this</a>     
        <br>  <a href="#p18">Qt</a>    
        <br>  <a href="#p19">Функции</a>
      </div>   
      <div id="content">
     
            
            <p id="p1"> </p>   
            
            <h3> Файлы </h3> 
            <blockquote> 
              <br> Главный файл кода — mani.cpp, который в некотором смысле центр управления программой. Внутри него только рычаги. Т. е. внутри него только описывается необходимая последовательность вызовов.   
              <br> Файл реализации — .cpp, в котором реализуется основная часть программы. Если главный файл называть центром управления, то файл реализации — это механизм, которым управляют.   
              <br> Файл заголовков — .h, который содержит общее описание используемых функций или просто названия переменных. Это эскиз некоторой программы. Этот файл используется для того, чтобы основной файл программы знал о существовании рычагов описанного в файле реализации механизма.  
            </blockquote>
                     
            <br> конструктор
            
            <p id="p2"></p>  
            <h3> Типы данных </h3> 
            
            
            <br>целочисленные:
            
            <br>short a = -10;
            <br>unsigned short b = 10;
            <br>int c = -30;
            <br>unsigned int d = 60;
            <br>long e = -170;
            <br>unsigned long f = 45;
            <br>long long g = 89;
            
            <br>вещественные:
            
            <br>float a = -10.45;
            <br>double b = 0.00105;
            <br>long double c = 30.890045;
            
            <br>строковые:
            
            <br>char
            <br>string (c библиотекой <code><string></code>)
            
            
            <p id="p3">  </p>  
            <h3> Set и Get </h3> 
            
            <br> Модификатор - изменение чего-либо, принято  использовать `Set();
            <br> Seting - установка. Устанавливаем значение в класс
                <pre>
                private:
                  int number;  // наша переменная
                public:
                  void set_number(int value) // set и тип переменной которую принимаем
                  {
                    number = value;//Устанавливаем значение для поля number   
                  }
                </pre>
            
                <p>
                  <br> Селектор - (от лат. сортировщик) - применяет
                  <br> Get - получить. Позволяет получить из класса .
                  <br> Get  должен иметь тот-же тип данных которые и возвращает.
                </p>
            
                <pre>
                  private:
                    int number;  // наша переменная
                  public:
                    int get_number() // get и переменная
                    {    
                      return number;  // которую возвращают
                    }
                </pre>
            
            <p id="p4"> </p>  
            <h3> Конструктор и деструктор </h3> 
                <p>
                <br> Позволяет  инициализировать переменные которые входят в состав класса во время объявления.
                </p>
                <p>
                  <br> Обязательно должны быть в `public:
                </p>
                <p>
                  <br>Конструктор без параметров -  просто инициализирует переменные
                  <br>Конструктор с параметрами - позволяет задать значения переменных во время
                  <br>создания нового класса. Пример `NameClass A (1, 2, 3);
                </p>
                <p>
                  <br>Деструктор вызывается как `~NameClass(){};` позволяет уничтожить из памяти инициализированные переменные
                </p>
            <p id="p5"> </p>  
            <h3> Ссылки и указатели </h3> 
              <p>
                <br> Указатель - это переменная, у неё есть свое значение и адрес памяти.
                <br> Значение указателя - адрес другой переменной.
                <br> Объявляется `int *pointer;` - указатель на переменную типа Int
                <br> Где звёздочку писать не имеет значения `int* p1; int *p2; int * p3;`
                <br> Нельзя несколько объявлять несколько указателей по одним типом ~~int* p1, p2;~~
              </P>
              <p>
                <br> Чтобы передать адрес переменной указателю нужно присвоит к указатель переменную со знаком &
                <br> Переменная получает адрес пример ` p1=&x;` где х обычна переменная.
              </p> 

             <pre>
              int  x= 2;
              int *p1;
              p1 = &x;// передаём значение х указатель p1
              cout << p1 << endl; // покажет адрес указателя
              cout << *p1 << endl; // покажет значение хранящееся в х
              cout << x << endl; // покажет переменную х
            </pre> 
            
            Если требуется, чтобы функция вернула несколько значений используется указатели. Пример:
            <pre>
              int swap(int *a,  int *b)
              {// функция переворачивает значение переменных местами
                  int temp = *a;// запоминаем значение a
                  *a = *b;// b присваивается a
                  *b = temp;// присваиваем b значение a которое запомнил temp
              }
              
              int main()
              {
                int q=1; int w=2;
                swap(&q, &w);// передаём значение указателем в функции
                cout << q << " - " << w << endl; // результат 2 - 1
              }
            </pre>
            <p id="p6"> </p>  
            <h3>  this </h3> 
            <p>
              <br> Ключевое слово this представляет указатель на текущий объект данного класса.
              <br> Через this мы можем обращаться внутри класса к любым его членам
              <br> Указатель объекта на сомого себя, знание объекта где (память) он находится    
            </p>
            
            <p id="p7">  </p>  
            <h3> Динамическая память </h3> 
            <p>
              <br> Стек -(англ. stack "стопка")бестрактный тип данных, представляющий собой список
              <br> элементов, организованных по принципу  «последним пришёл — первым вышел».
              <br> Объем памяти для стека выделяется немного.
              <br> В динамической памяти можно выдавать горазда больше.
              <br> 
              <br> Оператор delete не чего не удалят он возвращает память которая была выделена ранее
              <br> обратно в оперативную.
            </p>
            <p id="p8"> </p>  
            <h3> Русские буквы в консоли </h3> 
            
            <br> Работает в Visio studio, в Qt Creator нет
                <pre>
                  <code><windows.h></windows.h></code>// - библиотека
                  SetConsoleCP(1251);// установка кодовой страницы win-cp 1251 в поток ввода
                  SetConsoleOutputCP(1251); // для вывода
                </pre>
            
                <br>Qt Creator `setlocale (LC_ALL, "");` не помогает
                <br>Решение: библиотека - `#include <code><QTextStream></code>
               <pre>
                  QTextStream cin(stdin); cin.setCodec("CP866"); // ввода
                  QTextStream cout(stdout); cout.setCodec("CP866"); // вывод
                  cout << QString::fromUtf8("Текст ");
               </pre>

            <p id="p9"> </p>  
            <h3> Виртуальные функции  </h3> 
             <p>
              <br>К механизму виртуальных функций прибегают когда - в роизводном классе требуется
              <br>свой вариант некоторой компонентной функции.
              <br>Практически каждый класс, имеющий виртуальную функцию, должен иметь виртуальный деструктор.
             </p> 
          <pre>
              class Base
            
              public:
                virtual void print(){cout<<”\nBase”;}
            . . .
              };
              class Derive : public Base
              {
              public:
                void print(){cout<<”\n Derive”;}
              };
              void main()
              {
                Base B,*bp;
                Derive D,*dp;
                bp=&B;
                dp=&D;
              //указатель базового класса ставится на объект
              //производного класса
              Base *p = &D;
              bp –>print(); // вызывается метод для Base
              dp –>print(); // вызывается метод для Derive
              p –>print(); // вызывается метод для Derive
              }
            </pre>
            
            <p id="p10"></p>  
            <h3> Несколько файлов </h3> 
            
            <h5>Правила: </h5> 
            <br>* `# progma once` - пишется в начале .h файла что бы не было ошибки при объявлении повторяющихся сущностей
            <br>* не писать using namespace в .h иначе возможно замусорить глобальное пространство имён целого проекта.
            <br> .h  - заголовочный файл, описывает объекты    
            <br>.срр - здесь реализовываются функции или методы.    
            <br>В main потом вызывать только дочерний класс, вызов обоих приведёт к ошибке, повторное определение класса
            
            <p id="p11"> </p>  
            <h3> Компиляция линукс   </h3> 
            
            <br> Сборка из нескольких файлов  командной строке
            <br><code>++ -c main.cpp add.cpp -o main</code> - где main.cpp основной файл, > > add.cpp второй, main имя проекта        
            <br> Один файл
            <br> <code>g++ -o job main.cpp   </code>      
            <br> запуск ./job   
            
            <p id="p12"></p>  
            <h3> Системная пауза </h3> 
            
            <pre>
              #include <code><cstdlib></code>
              system("pause");
            </pre>
            
            <p> <code>std::endl**</code> не только вставляет символ перехода на новую строку, но еще и очищает буфер.
              <br>В большинстве простых задач это незаметно, но данный момент может на многое повлиять.
              <br>Из-за очистки буфера при каждом  применении, функция может, как упростить  работу с потоками,
              <br>так и сделать ее в несколько раз дольше - например, при записи крупного объема данных в файл –
              <br>программа каждый раз будет останавливаться, и записывать данные на диск. 
            </p>
            
            <p id="p13"> </p>  
            <h3> Перегрузка в классе   </h3> 
            
            Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>)
            
            <p id="p14"> </p>  
            <h3> Конструктор  </h3> 
              
            <pre>
              // Инициализация в классе
                Class_name() // конструктор без параметров
                {
                  min = 0; .....; // инициализация переменных
                }
              // создание объекта в main.cpp
                Class_name a;
              /* --------------------------------------------- */
              // Инициализация в классе
                Class_name(int n, ...) // конструктор без параметров
                {
                  min = n; .....; // инициализация переменных
                }
              // создание объекта в main.cpp
                Class_name a {1, .....}; // присваиваем значения для переменных при объявлении нового объекта   
            </pre>
            <p id="p15">  </p>  
            <h3> Важные ссылки </h3> 
            <a href="https://knowledge.allbest.ru/programming/3c0a65635b3ad68b5d43a88421206c26_0.html">Программа сортировки файла с данными </a> 
            <h3>  </h3> 
            <h3> Cи </h3>  
            <a href="https://younglinux.info/c">уроки </a> 
            <p id="p16"> </p>  
            <h3> Vector </h3> 
            
            <h5> Добавление   </h5> 
            
            <br>- push_back() - добавление в конец вектора, пример:
             <pre>
                vector<code><int></code> numbers;     // пустой вектор
                numbers.push_back(5); // Добавить элемент  конец
              </pre> 
            <br> - emplace(pos, value): вставляет элемент value на позицию, на которую указывает итератор pos   
            <pre>
              vector<code><int></code> numbers = { 1, 2, 3, 4, 5 };
              auto iter = numbers.cbegin();   // константный итератор указывает на первый элемент
              numbers.emplace(iter + 2, 8); // добавляем после второго элемента  numbers = { 1, 2, 8, 3, 4, 5};
            </pre> 

            <br>- insert(pos, value): вставляет элемент value на позицию, на которую указывает итератор pos, аналогично функции emplace
            
            <br>- insert(pos, n, value): вставляет n элементов value начиная с позиции, на которую указывает итератор pos
            
            <br>- insert(pos, begin, end): вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из диапазона между итераторами begin и end 
            <br>- insert(pos, values): вставляет список значений начиная с позиции, на которую указывает итератор pos   
           
            <h3> Удаление </h3> 
            
            <br>- clear() : удалить все элементы вектора    
            <br>- pop_back() : удалитьпоследний элемент    
            <br>- erase(p): удаляет элемент, на который указывает итератор p. Возвращает итератор на элемент, следующий после удаленного, или на конец контейнера, если удален последний элемент       
            <p> - erase(begin, end): удаляет элементы из диапазона, на начало и конец которого указывают итераторы begin и end. 
              Возвращает итератор на элемент, следующий после последнего удаленного, или на конец контейнера, если удален последний элемент
            </p>
            <pre>
              vector<code><int></code>numbers1 = { 1, 2, 3, 4, 5, 6 };
              auto iter = numbers1.cbegin(); // указатель на первый элемент
              numbers1.erase(iter + 2);   // удаляем третий элемент
              // numbers1 = { 1, 2, 4, 5, 6 }
              
              vector<code><int></code>numbers2 = { 1, 2, 3, 4, 5, 6 };
              auto begin = numbers2.cbegin(); // указатель на первый элемент
              auto end = numbers2.cend();     // указатель на последний элемент
              numbers2.erase(begin + 2, end - 1); // удаляем с третьего элемента до последнего
              // numbers2 = {1, 2, 6}
            </pre>
            <h4> Размер   </h4> 
            
            <br>- size() : размер вектора
            <h4> Изменение элементов вектора </h4> 
            
            <br> - assign() : изменить все элементы вектора  
            <pre>
            vector <code><string></code>names = { "Tom", "Bob", "Kate"};
            names.assign(4, "Sam"); // numbers = {"Sam", "Sam", "Sam", "Sam"}
            </pre>
            
            <br>- swap() : обменивает значения двух контейнеров.
            <pre>
              vector<string> clangs = { "C++", "C#", "Java" };
              vector<string> ilangs = { "JavaScript", "Python", "PHP"};
              clangs.swap(ilangs);    // clangs = { "JavaScript", "Python", "PHP"};
              for(string n : clangs) cout << n << "\t";
              cout << endl;
            </pre>
            <h4> Сравнение векторов </h4> 
            
            <br> Векторы можно сравнивать. Сравнение контейнеров осуществляется на основании сравнения пар элементов на тех же позициях. Векторы равны, если они содержат одинаковые элементы на тех же позициях  
            <pre>
              vector<code> <int> </code>v1 = {1, 2, 3};
              vector<code> <int> </code>v2 = {1, 2, 3};
              vector<code> <int> </code>> v3 = {3, 2, 1};
                  
              bool v1v2 = v1 == v2;   // true
              bool v1v3 = v1 != v3;   // true
              bool v2v3 = v2 == v3;   // false
            </pre>
            
            <p id="p17"> </p> 
            <h3> Указатель this </h3> 
            
            <br> Вот как для компилятора выглядит любой метод:     
            <pre>
              class Tank {
              private:
                int ammo;
              
              public:
                void Attack(Tank* this) {
                  this->ammo -= 1;
                }
              };
          </pre>
            <br> Это просто иллюстрация. В реальности не нужно указывать аргумент (всё что в круглых скобках). 
            <br> Мы автоматически получаем доступ к указателю this. В данном случае его использование перед ammo необязательно, 
            <br> компилятор автоматически привяжет эту переменную к this.     
            <br> Указатель this нужен, когда методу необходимо вернуть указатель на текущий объект.    
            
            <p id="p18"> </p>
            <h3> Qt </h3> 
            
            <h4> обращение к элементам формы </h4> 
            
            <pre>
              MainWindow::MainWindow(QWidget *parent)
                  : QMainWindow(parent)
                  , ui(new Ui::MainWindow)
              {
                  ui->setupUi(this);
                  ui->pushButton_2->setText("Hello");// название кнопки
              }
            </pre>
            <h4> Ключевые слова </h4> 
            explicit имеет смысл для конструкторов с 0,2,3 и более параметров (предотвращает неявное преобразование типов при инициализации.)       
            
            <h4> Булвивые опирации </h4>
            <p>
              И 	&& 	a == 3 && b > 4 	Составное условие истинно, если истинны оба простых условия
              ИЛИ 	|| 	a == 3 || b > 4 	Составное условие истинно, если истинно, хотя бы одно из простых условий
              НЕ 	! 	!( a == 3) 	Условие истинно, если a не равно 3
            </p>
            <p id="p19"> </p>
              <br> setprecision(n) - сокращение знаков после запятой, где n сколько оставить библиотека (#include iomanip)
              <br>fixed  - перевод непонятных чисел библиотека (#include iomanip)
            </p>
        
      </div>
      <div id="news">
      <nav>
        <dl>
            <dt> Содержание </dt>
            <dd>  <p><a href="Git.html"> Git </a></p>  </dd>
            <dd>  <p><a href="gdb.html"> gdb</a></p> </dd>
            <dd>  <p><a href="Atom.html"> Atom</a></p>  </dd>
            <dd>  <p><a href="CLI.html"> CLI </a></p>  </dd>
            <dd>  <p><a href="Emacs.html"> Emacs </a></p>  </dd>
            <dd>  <p><a href="html+css.html"> html+css </a></p>  </dd>
            <dd>  <p><a href="js.html"> JS</a></p>  </dd>
            <dd>  <p><a href="LateX.html"> LateX </a></p>  </dd>
            <dd>  <p><a href="linux.html"> Linux </a></p>  </dd>
            <dd>  <p><a href="Make_Manual.html"> Make_Manual </a></p>  </dd>
            <dd>  <p><a href="Markdown.html"> Markdown </a></p>  </dd>
            <dd>  <p><a href="QT.html"> QT </a></p>  </dd>
            <dd>  <p><a href="UML.html"> UML </a></p>  </dd>
            <dd>  <p><a href="Unreal_Engine4.html"> Unreal_Engine4 </a></p>  </dd>
            <dd>  <p><a href="Vim.html"> Vim </a></p>  </dd>
            <dd>  <p><a href="Work/Мощность приборов.html"> Мощность приборов </a></p>  </dd>
            <dd>  <p><a href="Work/ПЛК.html"> ПЛК </a></p>  </dd>
            <dd>  <p><a href="Work/ПЧ.html">ПЧ  </a></p>  </dd>
        </dl>
      </nav>
      </div> 
    </main>
    
    <footer>
      <div id="footer">низ сайта</div>  
    </footer> 
 
</body>
</html>