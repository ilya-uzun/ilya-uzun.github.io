<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <mate name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atom </title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
     <!-- Yandex.Metrika counter -->
     <script type="text/javascript" >
      (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
      m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
      (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

      ym(68914117, "init", {
          clickmap:true,
          trackLinks:true,
          accurateTrackBounce:true,
          webvisor:true
      });
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/68914117" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->       
    

    <header>
      <div id="header">шапка сайта</div>
    </header>
    <main>
      <div id="menu">
        <br>  <a href="#p1">Файлы</a>     
        <br>  <a href="#p2">типы данных</a>      
        <br>  <a href="#p3">Set и Get</a>     
        <br>  <a href="#p4">Конструктор и деструктор</a>     
        <br>  <a href="#p5">Ссылки и указатели</a>     
        <br>  <a href="#p6">this</a>     
        <br>  <a href="#p7">Динамическая память</a>     
        <br>  <a href="#p8">Русские буквы в консоли</a>     
        <br>  <a href="#p9">Виртуальные функции</a>     
        <br>  <a href="#p10">Несколько файлов</a>     
        <br>  <a href="#p11">Компиляция линукс</a>     
        <br>  <a href="#p12">Системная пауза</a>     
        <br>  <a href="#p13">перегрузка в классе</a>     
        <br>  <a href="#p14">Конструктор</a>     
        <br>  <a href="#p15">Важные ссылки</a>     
        <br>  <a href="#p16">Vector</a>     
        <br>  <a href="#p17">Указатель this</a>     
        <br>  <a href="#p18">Qt</a>    
        <br>  <a href="#p19">Функции</a>
      </div>   
      <div id="content">
     
            
            <p id="p1"> </p>   
            
            <h3> Файлы </h3> 
            <blockquote> 
              <br> Главный файл кода — mani.cpp, который в некотором смысле центр управления программой. Внутри него только рычаги. Т. е. внутри него только описывается необходимая последовательность вызовов.   
              <br> Файл реализации — .cpp, в котором реализуется основная часть программы. Если главный файл называть центром управления, то файл реализации — это механизм, которым управляют.   
              <br> Файл заголовков — .h, который содержит общее описание используемых функций или просто названия переменных. Это эскиз некоторой программы. Этот файл используется для того, чтобы основной файл программы знал о существовании рычагов описанного в файле реализации механизма.  
            </blockquote>
            
            
            конструктор
            
            <p id="p2"></p>  
            <h3> Типы данных </h3> 
            
            
            целочисленные:
            
            >short a = -10;
            >unsigned short b = 10;
            >int c = -30;
            >unsigned int d = 60;
            >long e = -170;
            >unsigned long f = 45;
            >long long g = 89;
            
            вещественные:
            
            >float a = -10.45;
            >double b = 0.00105;
            >long double c = 30.890045;
            
            строковые:
            
            >char
            >string (c библиотекой <string>)
            
            
            <p id="p3">  </p>  
            <h3> Set и Get </h3> 
            
            >Модификатор - изменение чего-либо, принято  использовать `Set();
            Seting - установка. Устанавливаем значение в класс
                <pre>
                private:
                  int number;  // наша переменная
                public:
                  void set_number(int value) // set и тип переменной которую принимаем
                  {
                    number = value;//Устанавливаем значение для поля number   
                  }
                </pre>
            
                <p>
                  <br> Селектор - (от лат. сортировщик) - применяет
                  <br> Get - получить. Позволяет получить из класса .
                  <br> Get  должен иметь тот-же тип данных которые и возвращает.
                </p>
            
                <pre>
                  private:
                    int number;  // наша переменная
                  public:
                    int get_number() // get и переменная
                    {    
                      return number;  // которую возвращают
                    }
                </pre>
            
            
            <p id="p4"> </p>  
            <h3> Конструктор и деструктор </h3> 
            
            Позволяет  инициализировать переменные которые входят в состав класса
            во время объявления.
            
            Обязательно должны быть в `public:
            
            Конструктор без параметров -  просто инициализирует переменные
            Конструктор с параметрами - позволяет задать значения переменных во время
            создания нового класса. Пример `NameClass A (1, 2, 3);
            
            Деструктор вызывается как `~NameClass(){};` позволяет уничтожить из памяти
            инициализированные переменные
            
            <p id="p5"> </p>  
            <h3> Ссылки и указатели </h3> 
            
            Указатель - это переменная, у неё есть свое значение и адрес памяти.
            Значение указателя - адрес другой переменной.
            Объявляется `int *pointer;` - указатель на переменную типа Int
            Где звёздочку писать не имеет значения `int* p1; int *p2; int * p3;`
            Нельзя несколько объявлять несколько указателей по одним типом ~~int* p1, p2;~~
            
            Чтобы передать адрес переменной указателю нужно присвоит к указатель переменную со знаком &
            Переменная получает адрес пример ` p1=&x;` где х обычна переменная.
            ~~~ C++
              int  x= 2;
              int *p1;
              p1 = &x;// передаём значение х указатель p1
              cout << p1 << endl; // покажет адрес указателя
              cout << *p1 << endl; // покажет значение хранящееся в х
              cout << x << endl; // покажет переменную х
            ~~~  
            
            Если требуется, чтобы функция вернула несколько значений используется указатели. Пример:
            ~~~ C++
            int swap(int *a,  int *b)
            {// функция переворачивает значение переменных местами
                int temp = *a;// запоминаем значение a
                *a = *b;// b присваивается a
                *b = temp;// присваиваем b значение a которое запомнил temp
            }
            
            int main()
            {
              int q=1; int w=2;
              swap(&q, &w);// передаём значение указателем в функции
              cout << q << " - " << w << endl; // результат 2 - 1
            }
            ~~~
            <p id="p6"> </p>  
            <h3>  this </h3> 
            
            Ключевое слово this представляет указатель на текущий объект данного класса.
            Через this мы можем обращаться внутри класса к любым его членам
            Указатель объекта на сомого себя, знание объекта где (память) он находится    
            
            
            <p id="p7">  </p>  
            <h3> Динамическая память </h3> 
            
            Стек -(англ. stack "стопка")бестрактный тип данных, представляющий собой список
            элементов, организованных по принципу  «последним пришёл — первым вышел».
            Объем памяти для стека выделяется немного.
            В динамической памяти можно выдавать горазда больше.
            
            Оператор delete не чего не удалят он возвращает память которая была выделена ранее
            обратно в оперативную.
            
            <p id="p8"> </p>  
            <h3> Русские буквы в консоли </h3> 
            
            Работает в Visio studio, в Qt Creator нет
            ~~~ C++
                <windows.h>// - библиотека
                SetConsoleCP(1251);// установка кодовой страницы win-cp 1251 в поток ввода
                SetConsoleOutputCP(1251); // для вывода
            ~~~
            
            Qt Creator `setlocale (LC_ALL, "");` не помогает
            Решение: библиотека - `#include <QTextStream>`
            ~~~ C++
                QTextStream cin(stdin); cin.setCodec("CP866"); // ввода
                QTextStream cout(stdout); cout.setCodec("CP866"); // вывод
                cout << QString::fromUtf8("Текст ");
            ~~~
            
            <p id="p9"> </p>  
            <h3> Виртуальные функции  </h3> 
              
            К механизму виртуальных функций прибегают когда - в роизводном классе требуется
            свой вариант некоторой компонентной функции.
            Практически каждый класс, имеющий виртуальную функцию, должен иметь виртуальный
            деструктор.
            ``` C++
              class Base
            
              public:
                virtual void print(){cout<<”\nBase”;}
            . . .
              };
              class Derive : public Base
              {
              public:
                void print(){cout<<”\n Derive”;}
              };
              void main()
              {
                Base B,*bp;
                Derive D,*dp;
                bp=&B;
                dp=&D;
              //указатель базового класса ставится на объект
              //производного класса
              Base *p = &D;
              bp –>print(); // вызывается метод для Base
              dp –>print(); // вызывается метод для Derive
              p –>print(); // вызывается метод для Derive
              }
            ```
            
            <p id="p10"></p>  
            <h3> Несколько файлов </h3> 
            
            Правила:  
            * `# progma once` - пишется в начале .h файла что бы не было ошибки при объявлении повторяющихся сущностей
            * не писать using namespace в .h иначе возможно замусорить глобальное пространство имён целого проекта.
            > .h  - заголовочный файл, описывает объекты    
              .срр - здесь реализовываются функции или методы.    
              В main потом вызывать только дочерний класс, вызов обоих приведёт к ошибке, повторное определение класса
            > 
            
            <p id="p11"> </p>  
            <h3> Компиляция линукс   </h3> 
            
            > Сборка из нескольких файлов  командной строке
            >`g++ -c main.cpp add.cpp -o main` - где main.cpp основной файл, > > add.cpp второй, main имя проекта        
            
            > Один файл
            > g++ -o job main.cpp      
            
            > запуск ./job   
            
            <p id="p12"></p>  
            <h3> Системная пауза </h3> 
            
            ``` C++
            #include <cstdlib>
            system("pause");
            ```
            
            **std::endl** не только вставляет символ перехода на новую строку, но еще и очищает буфер.
            В большинстве простых задач это незаметно, но данный момент может на многое повлиять.
            Из-за очистки буфера при каждом  применении, функция может, как упростить  работу с потоками,
            так и сделать ее в несколько раз дольше - например, при записи крупного объема данных в файл –
            программа каждый раз будет останавливаться, и записывать данные на диск.
            
            <p id="p13"> </p>  
            <h3> Перегрузка в классе   </h3> 
            
            Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>)
            
            <p id="p14"> </p>  
            <h3> Конструктор  </h3> 
              
            ~~~ C++
            // Инициализация в классе
              Class_name() // конструктор без параметров
              {
                min = 0; .....; // инициализация переменных
              }
            // создание объекта в main.cpp
              Class_name a;
            /* --------------------------------------------- */
            // Инициализация в классе
              Class_name(int n, ...) // конструктор без параметров
              {
                min = n; .....; // инициализация переменных
              }
            // создание объекта в main.cpp
              Class_name a {1, .....}; // присваиваем значения для переменных при объявлении нового объекта   
            ~~~
            <p id="p15">  </p>  
            <h3> Важные ссылки </h3> 
            <a href="https://knowledge.allbest.ru/programming/3c0a65635b3ad68b5d43a88421206c26_0.html">Программа сортировки файла с данными </a> 
            <h3>  </h3> 
            <h3> Cи </h3>  
            <a href="https://younglinux.info/c">уроки </a> 
            <p id="p16"> </p>  
            <h3> Vector </h3> 
            
            <h5> Добавление   </h5> 
              
            
            - push_back() - добавление в конец вектора, пример:
            ~~~ c++
              vector<int> numbers;     // пустой вектор
              numbers.push_back(5); // Добавить элемент  конец
            ~~~   
            - emplace(pos, value): вставляет элемент value на позицию, на которую указывает итератор pos   
            ~~~ C++
            vector<int> numbers = { 1, 2, 3, 4, 5 };
            auto iter = numbers.cbegin();   // константный итератор указывает на первый элемент
            numbers.emplace(iter + 2, 8); // добавляем после второго элемента  numbers = { 1, 2, 8, 3, 4, 5};
            ~~~ 
            - insert(pos, value): вставляет элемент value на позицию, на которую указывает итератор pos, аналогично функции emplace
            
            - insert(pos, n, value): вставляет n элементов value начиная с позиции, на которую указывает итератор pos
            
            - insert(pos, begin, end): вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из диапазона между итераторами begin и end
            
            - insert(pos, values): вставляет список значений начиная с позиции, на которую указывает итератор pos   
            
            <h3> Удаление </h3> 
            
            - clear() : удалить все элементы вектора    
            
            - pop_back() : удалитьпоследний элемент
            
            - erase(p): удаляет элемент, на который указывает итератор p. Возвращает итератор на элемент, следующий после удаленного, или на конец контейнера, если удален последний элемент
            
            - erase(begin, end): удаляет элементы из диапазона, на начало и конец которого указывают итераторы begin и end. Возвращает итератор на элемент, следующий после последнего удаленного, или на конец контейнера, если удален последний элемент
            ~~~ C++
            vector<int> numbers1 = { 1, 2, 3, 4, 5, 6 };
            auto iter = numbers1.cbegin(); // указатель на первый элемент
            numbers1.erase(iter + 2);   // удаляем третий элемент
            // numbers1 = { 1, 2, 4, 5, 6 }
            
            vector<int> numbers2 = { 1, 2, 3, 4, 5, 6 };
            auto begin = numbers2.cbegin(); // указатель на первый элемент
            auto end = numbers2.cend();     // указатель на последний элемент
            numbers2.erase(begin + 2, end - 1); // удаляем с третьего элемента до последнего
            // numbers2 = {1, 2, 6}
            ~~~ 
            <h4> Размер   </h4> 
            
            - size() : размер вектора
            <h4> Изменение элементов вектора </h4> 
            
            - assign() : изменить все элементы вектора  
            ~~~ C++
            vector<string> names = { "Tom", "Bob", "Kate"};
            names.assign(4, "Sam"); // numbers = {"Sam", "Sam", "Sam", "Sam"}
            ~~~
            
            - swap() : обменивает значения двух контейнеров.
            ~~~ C++
            vector<string> clangs = { "C++", "C#", "Java" };
            vector<string> ilangs = { "JavaScript", "Python", "PHP"};
            clangs.swap(ilangs);    // clangs = { "JavaScript", "Python", "PHP"};
            for(string n : clangs) cout << n << "\t";
            cout << endl;
            ~~~
            <h4> Сравнение векторов </h4> 
            
            > Векторы можно сравнивать. Сравнение контейнеров осуществляется на основании сравнения пар элементов на тех же позициях. Векторы равны, если они содержат одинаковые элементы на тех же позициях  
            ~~~ C++
            vector<int> v1 = {1, 2, 3};
            vector<int> v2 = {1, 2, 3};
            vector<int> v3 = {3, 2, 1};
                
            bool v1v2 = v1 == v2;   // true
            bool v1v3 = v1 != v3;   // true
            bool v2v3 = v2 == v3;   // false
            ~~~
            
            <p id="p17"> </p> 
            <h3> Указатель this </h3> 
            
            Вот как для компилятора выглядит любой метод:     
            ~~~C++
            class Tank {
            private:
              int ammo;
            
            public:
              void Attack(Tank* this) {
                this->ammo -= 1;
              }
            };
            ~~~
            Это просто иллюстрация. В реальности не нужно указывать аргумент (всё что в круглых скобках). Мы автоматически получаем доступ к указателю this. В данном случае его использование перед ammo необязательно, компилятор автоматически привяжет эту переменную к this.     
            
            Указатель this нужен, когда методу необходимо вернуть указатель на текущий объект.    
            
            <p id="p18"> </p>
            <h3> Qt </h3> 
            
            <h4> обращение к элементам формы </h4> 
            
            ~~~c++
            MainWindow::MainWindow(QWidget *parent)
                : QMainWindow(parent)
                , ui(new Ui::MainWindow)
            {
                ui->setupUi(this);
                ui->pushButton_2->setText("Hello");// название кнопки
            }
            ~~~
            <h4> Ключевые слова </h4> 
            explicit имеет смысл для конструкторов с 0,2,3 и более параметров (предотвращает неявное преобразование типов при инициализации.)       
            
            <h4> Булвивые опирации </h4>
            <p>
            И 	&& 	a == 3 && b > 4 	Составное условие истинно, если истинны оба простых условия
            ИЛИ 	|| 	a == 3 || b > 4 	Составное условие истинно, если истинно, хотя бы одно из простых условий
            НЕ 	! 	!( a == 3) 	Условие истинно, если a не равно 3
            
            <p id="p19"> </p>
            setprecision(n) - сокращение знаков после запятой, где n сколько оставить библиотека (#include iomanip)
            fixed  - перевод непонятных чисел библиотека (#include iomanip)
            </p>
        
      </div>
      <div id="news">
      <nav>
        <dl>
            <dt> Содержание </dt>
            <dd>  <p><a href="Git.html"> Git </a></p>  </dd>
            <dd>  <p><a href="gdb.html"> gdb</a></p> </dd>
            <dd>  <p><a href="Atom.html"> Atom</a></p>  </dd>
            <dd>  <p><a href="CLI.html"> CLI </a></p>  </dd>
            <dd>  <p><a href="Emacs.html"> Emacs </a></p>  </dd>
            <dd>  <p><a href="html+css.html"> html+css </a></p>  </dd>
            <dd>  <p><a href="js.html"> JS</a></p>  </dd>
            <dd>  <p><a href="LateX.html"> LateX </a></p>  </dd>
            <dd>  <p><a href="linux.html"> Linux </a></p>  </dd>
            <dd>  <p><a href="Make_Manual.html"> Make_Manual </a></p>  </dd>
            <dd>  <p><a href="Markdown.html"> Markdown </a></p>  </dd>
            <dd>  <p><a href="QT.html"> QT </a></p>  </dd>
            <dd>  <p><a href="UML.html"> UML </a></p>  </dd>
            <dd>  <p><a href="Unreal_Engine4.html"> Unreal_Engine4 </a></p>  </dd>
            <dd>  <p><a href="Vim.html"> Vim </a></p>  </dd>
            <dd>  <p><a href="Work/Мощность приборов.html"> Мощность приборов </a></p>  </dd>
            <dd>  <p><a href="Work/ПЛК.html"> ПЛК </a></p>  </dd>
            <dd>  <p><a href="Work/ПЧ.html">ПЧ  </a></p>  </dd>
        </dl>
      </nav>
      </div> 
    </main>
    
    <footer>
      <div id="footer">низ сайта</div>  
    </footer> 





   
</body>
</html>