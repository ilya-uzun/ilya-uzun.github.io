<a href="#p1">Файлы</a>     
<a href="#p2">типы данных</a>      
<a href="#p3">Set и Get</a>     
<a href="#p4">Конструктор и деструктор</a>     
<a href="#p5">Ссылки и указатели</a>     
<a href="#p6">this</a>     
<a href="#p7">Динамическая память</a>     
<a href="#p8">Русские буквы в консоли</a>     
<a href="#p9">Виртуальные функции</a>     
<a href="#p10">Несколько файлов</a>     
<a href="#p11">Компиляция линукс</a>     
<a href="#p12">Системная пауза</a>     
<a href="#p13">перегрузка в классе</a>     
<a href="#p14">Конструктор</a>     
<a href="#p15">Важные ссылки</a>     
<a href="#p16">Vector</a>     
<a href="#p17">Указатель this</a>     
<a href="#p18">Qt</a>     


<p id="p1"> </p>   

## Файлы 
>Главный файл кода — mani.cpp, который в некотором смысле центр управления программой. Внутри него только рычаги. Т. е. внутри него только описывается необходимая последовательность вызовов.   
>Файл реализации — .cpp, в котором реализуется основная часть программы. Если главный файл называть центром управления, то файл реализации — это механизм, которым управляют.   
>Файл заголовков — .h, который содержит общее описание используемых функций или просто названия переменных. Это эскиз некоторой программы. Этот файл используется для того, чтобы основной файл программы знал о существовании рычагов описанного в файле реализации механизма. 


конструктор

<p id="p2"></p>  

## типы данных

целочисленные:

>short a = -10;
>unsigned short b = 10;
>int c = -30;
>unsigned int d = 60;
>long e = -170;
>unsigned long f = 45;
>long long g = 89;

вещественные:

>float a = -10.45;
>double b = 0.00105;
>long double c = 30.890045;

строковые:

>char
>string (c библиотекой <string>)


<p id="p3">  </p>  

## Set и Get
>Модификатор - изменение чего-либо, принято  использовать `Set();
Seting - установка. Устанавливаем значение в класс
~~~C++
private:
	int number;  // наша переменная
public:
	void set_number(int value) // set и тип переменной которую принимаем
	{
	  number = value;//Устанавливаем значение для поля number   
	}
~~~
>Селектор - (от лат. сортировщик) - применяет
Get - получить. Позволяет получить из класса .
Get  должен иметь тот-же тип данных которые и возвращает.
~~~ C++
private:
	int number;  // наша переменная
public:
	int get_number() // get и переменная
	{    
	  return number;  // которую возвращают
	}
~~~

<p id="p4"> </p>  

## Конструктор и деструктор
Позволяет  инициализировать переменные которые входят в состав класса
во время объявления.

Обязательно должны быть в `public:

Конструктор без параметров -  просто инициализирует переменные
Конструктор с параметрами - позволяет задать значения переменных во время
создания нового класса. Пример `NameClass A (1, 2, 3);

Деструктор вызывается как `~NameClass(){};` позволяет уничтожить из памяти
инициализированные переменные

<p id="p5"> </p>  

## Ссылки и указатели
Указатель - это переменная, у неё есть свое значение и адрес памяти.
Значение указателя - адрес другой переменной.
Объявляется `int *pointer;` - указатель на переменную типа Int
Где звёздочку писать не имеет значения `int* p1; int *p2; int * p3;`
Нельзя несколько объявлять несколько указателей по одним типом ~~int* p1, p2;~~

Чтобы передать адрес переменной указателю нужно присвоит к указатель переменную со знаком &
Переменная получает адрес пример ` p1=&x;` где х обычна переменная.
~~~ C++
  int  x= 2;
  int *p1;
  p1 = &x;// передаём значение х указатель p1
  cout << p1 << endl; // покажет адрес указателя
  cout << *p1 << endl; // покажет значение хранящееся в х
  cout << x << endl; // покажет переменную х
~~~  

Если требуется, чтобы функция вернула несколько значений используется указатели. Пример:
~~~ C++
int swap(int *a,  int *b)
{// функция переворачивает значение переменных местами
    int temp = *a;// запоминаем значение a
    *a = *b;// b присваивается a
    *b = temp;// присваиваем b значение a которое запомнил temp
}

int main()
{
   int q=1; int w=2;
   swap(&q, &w);// передаём значение указателем в функции
   cout << q << " - " << w << endl; // результат 2 - 1
}
~~~
<p id="p6"> </p>  

#### this
Ключевое слово this представляет указатель на текущий объект данного класса.
Через this мы можем обращаться внутри класса к любым его членам
Указатель объекта на сомого себя, знание объекта где (память) он находится    


<p id="p7">  </p>  

## Динамическая память
Стек -(англ. stack "стопка")бестрактный тип данных, представляющий собой список
элементов, организованных по принципу  «последним пришёл — первым вышел».
Объем памяти для стека выделяется немного.
В динамической памяти можно выдавать горазда больше.

Оператор delete не чего не удалят он возвращает память которая была выделена ранее
обратно в оперативную.

<p id="p8"> </p>  

## Русские буквы в консоли
Работает в Visio studio, в Qt Creator нет
~~~ C++
    <windows.h>// - библиотека
    SetConsoleCP(1251);// установка кодовой страницы win-cp 1251 в поток ввода
    SetConsoleOutputCP(1251); // для вывода
~~~

Qt Creator `setlocale (LC_ALL, "");` не помогает
Решение: библиотека - `#include <QTextStream>`
~~~ C++
    QTextStream cin(stdin); cin.setCodec("CP866"); // ввода
    QTextStream cout(stdout); cout.setCodec("CP866"); // вывод
    cout << QString::fromUtf8("Текст ");
~~~

<p id="p9"> </p>  

### Виртуальные функции    
К механизму виртуальных функций прибегают когда - в роизводном классе требуется
свой вариант некоторой компонентной функции.
Практически каждый класс, имеющий виртуальную функцию, должен иметь виртуальный
деструктор.
``` C++
  class Base

  public:
    virtual void print(){cout<<”\nBase”;}
. . .
  };
  class Derive : public Base
  {
  public:
    void print(){cout<<”\n Derive”;}
  };
  void main()
  {
    Base B,*bp;
    Derive D,*dp;
    bp=&B;
    dp=&D;
  //указатель базового класса ставится на объект
  //производного класса
  Base *p = &D;
  bp –>print(); // вызывается метод для Base
  dp –>print(); // вызывается метод для Derive
  p –>print(); // вызывается метод для Derive
  }
```

<p id="p10"></p>  

## Несколько файлов
Правила:  
* `# progma once` - пишется в начале .h файла что бы не было ошибки при объявлении повторяющихся сущностей
* не писать using namespace в .h иначе возможно замусорить глобальное пространство имён целого проекта.
> .h  - заголовочный файл, описывает объекты    
  .срр - здесь реализовываются функции или методы.    
  В main потом вызывать только дочерний класс, вызов обоих приведёт к ошибке, повторное определение класса
> 

<p id="p11"> </p>  

## Компиляция линукс  
> Сборка из нескольких файлов  командной строке
>`g++ -c main.cpp add.cpp -o main` - где main.cpp основной файл, > > add.cpp второй, main имя проекта        

> Один файл
> g++ -o job main.cpp      

> запуск ./job   

<p id="p12"></p>  

### Системная пауза
``` C++
#include <cstdlib>
system("pause");
```

**std::endl** не только вставляет символ перехода на новую строку, но еще и очищает буфер.
В большинстве простых задач это незаметно, но данный момент может на многое повлиять.
Из-за очистки буфера при каждом  применении, функция может, как упростить  работу с потоками,
так и сделать ее в несколько раз дольше - например, при записи крупного объема данных в файл –
программа каждый раз будет останавливаться, и записывать данные на диск.

<p id="p13"> </p>  

## перегрузка в классе   
Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>)

<p id="p14"> </p>  

## Конструктор   
~~~ C++
// Инициализация в классе
	Class_name() // конструктор без параметров
	{
		min = 0; .....; // инициализация переменных
	}
// создание объекта в main.cpp
  Class_name a;
/* --------------------------------------------- */
// Инициализация в классе
	Class_name(int n, ...) // конструктор без параметров
	{
		min = n; .....; // инициализация переменных
	}
// создание объекта в main.cpp
  Class_name a {1, .....}; // присваиваем значения для переменных при объявлении нового объекта   
~~~
<p id="p15">  </p>  

### Важные ссылки
[Программа сортировки файла с данными](https://knowledge.allbest.ru/programming/3c0a65635b3ad68b5d43a88421206c26_0.html)

## Cи
[уроки](https://younglinux.info/c)   

<p id="p16"> </p>  

## vector
#### добавление    

- push_back() - добавление в конец вектора, пример:
~~~ c++
  vector<int> numbers;     // пустой вектор
  numbers.push_back(5); // Добавить элемент  конец
~~~   
- emplace(pos, value): вставляет элемент value на позицию, на которую указывает итератор pos   
~~~ C++
vector<int> numbers = { 1, 2, 3, 4, 5 };
auto iter = numbers.cbegin();   // константный итератор указывает на первый элемент
numbers.emplace(iter + 2, 8); // добавляем после второго элемента  numbers = { 1, 2, 8, 3, 4, 5};
~~~ 
- insert(pos, value): вставляет элемент value на позицию, на которую указывает итератор pos, аналогично функции emplace

- insert(pos, n, value): вставляет n элементов value начиная с позиции, на которую указывает итератор pos

- insert(pos, begin, end): вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из диапазона между итераторами begin и end

- insert(pos, values): вставляет список значений начиная с позиции, на которую указывает итератор pos   

#### Удаление

- clear() : удалить все элементы вектора    

- pop_back() : удалитьпоследний элемент

- erase(p): удаляет элемент, на который указывает итератор p. Возвращает итератор на элемент, следующий после удаленного, или на конец контейнера, если удален последний элемент

- erase(begin, end): удаляет элементы из диапазона, на начало и конец которого указывают итераторы begin и end. Возвращает итератор на элемент, следующий после последнего удаленного, или на конец контейнера, если удален последний элемент
~~~ C++
vector<int> numbers1 = { 1, 2, 3, 4, 5, 6 };
auto iter = numbers1.cbegin(); // указатель на первый элемент
numbers1.erase(iter + 2);   // удаляем третий элемент
// numbers1 = { 1, 2, 4, 5, 6 }
 
vector<int> numbers2 = { 1, 2, 3, 4, 5, 6 };
auto begin = numbers2.cbegin(); // указатель на первый элемент
auto end = numbers2.cend();     // указатель на последний элемент
numbers2.erase(begin + 2, end - 1); // удаляем с третьего элемента до последнего
// numbers2 = {1, 2, 6}
~~~ 

#### Размер  

- size() : размер вектора

#### Изменение элементов вектора

- assign() : изменить все элементы вектора  
~~~ C++
vector<string> names = { "Tom", "Bob", "Kate"};
names.assign(4, "Sam"); // numbers = {"Sam", "Sam", "Sam", "Sam"}
~~~

- swap() : обменивает значения двух контейнеров.
~~~ C++
vector<string> clangs = { "C++", "C#", "Java" };
vector<string> ilangs = { "JavaScript", "Python", "PHP"};
clangs.swap(ilangs);    // clangs = { "JavaScript", "Python", "PHP"};
for(string n : clangs) cout << n << "\t";
cout << endl;
~~~

#### Сравнение векторов
> Векторы можно сравнивать. Сравнение контейнеров осуществляется на основании сравнения пар элементов на тех же позициях. Векторы равны, если они содержат одинаковые элементы на тех же позициях  
~~~ C++
vector<int> v1 = {1, 2, 3};
vector<int> v2 = {1, 2, 3};
vector<int> v3 = {3, 2, 1};
     
bool v1v2 = v1 == v2;   // true
bool v1v3 = v1 != v3;   // true
bool v2v3 = v2 == v3;   // false
~~~

<p id="p17"> </p> 

#### Указатель this

Вот как для компилятора выглядит любой метод:     
~~~C++
class Tank {
private:
  int ammo;

public:
  void Attack(Tank* this) {
    this->ammo -= 1;
  }
};
~~~
Это просто иллюстрация. В реальности не нужно указывать аргумент (всё что в круглых скобках). Мы автоматически получаем доступ к указателю this. В данном случае его использование перед ammo необязательно, компилятор автоматически привяжет эту переменную к this.     

Указатель this нужен, когда методу необходимо вернуть указатель на текущий объект.    

<p id="p18"> </p>

## Qt
### обращение к элементам формы

~~~c++
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    ui->pushButton_2->setText("Hello");// название кнопки
}
~~~

#### Ключевые слова
> explicit имеет смысл для конструкторов с 0,2,3 и более параметров (предотвращает неявное преобразование типов при инициализации.)       
